<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>K-Pixel War (Final Fix)</title>
    <script type="text/javascript" src="https://oapi.map.naver.com/openapi/v3/maps.js?ncpKeyId=zx8lobio6s"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.5.1/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; }
        #game-container { position: relative; width: 100vw; height: 100vh; background-color: #f0f0f0; }
        #map { width: 100%; height: 100%; z-index: 1; will-change: transform; }
        #pixelCanvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
        }
        .ui-panel {
            position: absolute; top: 20px; right: 20px; z-index: 100;
            background: rgba(255, 255, 255, 0.95); padding: 15px;
            border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            font-family: 'Noto Sans KR', sans-serif;
        }
        .mode-btn { width: 100%; padding: 10px; margin-bottom: 10px; cursor: pointer; font-weight: bold; border-radius: 5px; transition: 0.2s; }
        .mode-move { background: #4CAF50; color: white; border: none; }
        .mode-attack { background: #f44336; color: white; border: none; }
        .attack-cursor { cursor: crosshair !important; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="map"></div>
    <canvas id="pixelCanvas"></canvas>

    <div class="ui-panel">
        <button id="modeBtn" class="mode-btn mode-move">ğŸ“ ì´ë™ ëª¨ë“œ</button>
        <hr>
        ìƒ‰ìƒ: <input type="color" id="colorPicker" value="#ff0000"><br><br>
        ID: <input type="text" id="userId" value="player1" style="width: 80px;">
    </div>
</div>

<script>
    // --- ì„¤ì • ---
    const GRID_SIZE = 0.0001;
    const MIN_ZOOM = 16;
    const MAX_ZOOM = 21;

    let isAttackMode = false;
    let pixelMap = new Map();

    // --- ì§€ë„ ì´ˆê¸°í™” ---
    const map = new naver.maps.Map('map', {
        center: new naver.maps.LatLng(37.3595704, 127.105399),
        zoom: 18,
        minZoom: MIN_ZOOM,
        maxZoom: MAX_ZOOM,
        draggable: true, scrollWheel: true, disableDoubleClickZoom: true, tileTransition: true
    });

    // --- ìº”ë²„ìŠ¤ ì„¤ì • ---
    const canvas = document.getElementById('pixelCanvas');
    const ctx = canvas.getContext('2d');
    let isDrawing = false, needsRedraw = false;

    function scheduleDraw() {
        needsRedraw = true;
        if (!isDrawing) { isDrawing = true; requestAnimationFrame(drawLoop); }
    }

    function drawLoop() {
        if (needsRedraw) { drawPixels(); needsRedraw = false; requestAnimationFrame(drawLoop); }
        else { isDrawing = false; }
    }

    function resizeCanvas() {
        const size = map.getSize();
        if (size.width === 0 || size.height === 0) return;
        canvas.width = size.width;
        canvas.height = size.height;
        scheduleDraw();
    }
    window.addEventListener('resize', resizeCanvas);

    // --- í”½ì…€ ê·¸ë¦¬ê¸° (ì¢Œí‘œ ë³´ì • ë¡œì§ ì ìš©) ---
    function drawPixels() {
        const projection = map.getProjection();
        const bounds = map.getBounds();

        if (!bounds || !projection) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // í™”ë©´ ê¸°ì¤€ì  ê³„ì‚° (ë¶ì„œìª½)
        const nwLat = bounds.getNE().lat();
        const nwLng = bounds.getSW().lng();
        const tlOffset = projection.fromCoordToOffset(new naver.maps.LatLng(nwLat, nwLng));

        // ê²©ì í¬ê¸° ê³„ì‚°
        const center = map.getCenter();
        const centerOffset = projection.fromCoordToOffset(center);
        const nextGridOffset = projection.fromCoordToOffset(
            new naver.maps.LatLng(center.lat() + GRID_SIZE, center.lng() + GRID_SIZE)
        );

        let pixelW = Math.abs(nextGridOffset.x - centerOffset.x);
        let pixelH = Math.abs(nextGridOffset.y - centerOffset.y);

        pixelW = Math.max(pixelW, 1);
        pixelH = Math.max(pixelH, 1);

        ctx.beginPath();
        pixelMap.forEach((p) => {
            // [ì¤‘ìš” ìˆ˜ì •] p.lat, p.lngì€ 'ë‚¨ì„œìª½' ì¢Œí‘œì…ë‹ˆë‹¤. (floorë¡œ ì €ì¥í–ˆìœ¼ë¯€ë¡œ)
            // HTML CanvasëŠ” ì¢Œìƒë‹¨(Top-Left)ì—ì„œ ì‹œì‘í•´ ì•„ë˜ë¡œ ê·¸ë¦½ë‹ˆë‹¤.
            // ë”°ë¼ì„œ í”½ì…€ì˜ 'ë¶ì„œìª½(Top-Left)' ì¢Œí‘œë¥¼ êµ¬í•´ì•¼ ì •í™•íˆ ë§ˆìš°ìŠ¤ ì•„ë˜ì— ê·¸ë ¤ì§‘ë‹ˆë‹¤.
            // ìœ„ë„(Lat)ì— GRID_SIZEë¥¼ ë”í•´ì£¼ë©´ ë¶ìª½ ê²½ê³„ì„ ì´ ë©ë‹ˆë‹¤.
            const drawLat = p.lat + GRID_SIZE;
            const drawLng = p.lng;

            const latLng = new naver.maps.LatLng(drawLat, drawLng);

            // í™”ë©´ ë²”ìœ„ ì²´í¬ (ì•½ê°„ì˜ ì—¬ìœ ë¥¼ ë‘ )
            if (bounds.hasLatLng(new naver.maps.LatLng(p.lat, p.lng))) {
                const pOffset = projection.fromCoordToOffset(latLng);

                const x = pOffset.x - tlOffset.x;
                const y = pOffset.y - tlOffset.y;

                ctx.fillStyle = p.color;
                // ì •ìˆ˜ ì¢Œí‘œë¡œ ë Œë”ë§
                ctx.fillRect(Math.floor(x), Math.floor(y), Math.ceil(pixelW), Math.ceil(pixelH));
            }
        });
    }

    // --- ì´ë²¤íŠ¸ ---
    naver.maps.Event.addListener(map, 'idle', scheduleDraw);
    naver.maps.Event.addListener(map, 'center_changed', scheduleDraw);
    naver.maps.Event.addListener(map, 'zoom_changed', scheduleDraw);
    naver.maps.Event.addListener(map, 'init', resizeCanvas);

    // --- ë°ì´í„° ìˆ˜ì‹  ---
    function updatePixelData(pixel) {
        const key = `${pixel.lat.toFixed(4)},${pixel.lng.toFixed(4)}`;
        pixelMap.set(key, pixel);
        scheduleDraw();
    }

    // ì´ˆê¸° ë°ì´í„° ë¡œë“œ
    fetch('/api/pixels')
        .then(res => res.json())
        .then(data => {
            if(Array.isArray(data)) data.forEach(p => updatePixelData(p));
        })
        .catch(err => console.warn("API í˜¸ì¶œ ì‹¤íŒ¨:", err));

    // ì›¹ì†Œì¼“
    const socket = new SockJS('/ws-pixel');
    const stompClient = Stomp.over(socket);
    stompClient.connect({}, () => {
        stompClient.subscribe('/topic/pixel', (msg) => {
            updatePixelData(JSON.parse(msg.body));
        });
    });

    // --- í´ë¦­ ì´ë²¤íŠ¸ (ì¢Œí‘œ ê³„ì‚° ë¡œì§ ë³€ê²½) ---
    naver.maps.Event.addListener(map, 'click', function(e) {
        if (!isAttackMode) return;

        const rawLat = e.coord.lat();
        const rawLng = e.coord.lng();

        // [ì¤‘ìš” ìˆ˜ì •] ë°˜ì˜¬ë¦¼(round) ëŒ€ì‹  ë‚´ë¦¼(floor) ì‚¬ìš©
        // í´ë¦­í•œ ë§ˆìš°ìŠ¤ ì¢Œí‘œê°€ í¬í•¨ëœ ê²©ìì˜ "ì‹œì‘ì "ì„ ì¡ìŠµë‹ˆë‹¤.
        const snapLat = Math.floor(rawLat * 10000) / 10000;
        const snapLng = Math.floor(rawLng * 10000) / 10000;

        const newPixel = {
            lat: snapLat,
            lng: snapLng,
            color: document.getElementById('colorPicker').value,
            userId: document.getElementById('userId').value
        };

        updatePixelData(newPixel);

        fetch('/api/pixels', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(newPixel)
        });
    });

    // --- UI í•¸ë“¤ëŸ¬ ---
    const modeBtn = document.getElementById('modeBtn');
    const mapDiv = document.getElementById('map');

    modeBtn.addEventListener('click', () => {
        isAttackMode = !isAttackMode;
        if (isAttackMode) {
            modeBtn.innerText = "âš”ï¸ ê³µê²© ëª¨ë“œ";
            modeBtn.className = "mode-btn mode-attack";
            map.setOptions({ draggable: false, scrollWheel: false, disableDoubleClickZoom: true });
            mapDiv.classList.add('attack-cursor');
        } else {
            modeBtn.innerText = "ğŸ“ ì´ë™ ëª¨ë“œ";
            modeBtn.className = "mode-btn mode-move";
            map.setOptions({ draggable: true, scrollWheel: true, disableDoubleClickZoom: true });
            mapDiv.classList.remove('attack-cursor');
        }
    });

    setTimeout(resizeCanvas, 500);
</script>
</body>
</html>