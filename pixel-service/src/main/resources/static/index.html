<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>The Pixel War</title>
    <script type="text/javascript" src="https://oapi.map.naver.com/openapi/v3/maps.js?ncpKeyId=zx8lobio6s"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.5.1/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #f0f0f0; }
        #game-container { position: relative; width: 100vw; height: 100vh; }

        #map { width: 100%; height: 100%; z-index: 1; will-change: transform; }

        /* [ê¸°ì¡´] ì‹¤ì œ í”½ì…€ë“¤ì´ ê·¸ë ¤ì§€ëŠ” ìº”ë²„ìŠ¤ (z-index: 10) */
        #pixelCanvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
        }

        /* [ì¶”ê°€] ì»¤ì„œ ë¯¸ë¦¬ë³´ê¸°ìš© ìº”ë²„ìŠ¤ (z-index: 11) */
        #previewCanvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 11; pointer-events: none;
        }

        .ui-panel {
            position: absolute; top: 20px; right: 20px; z-index: 100;
            background: rgba(255, 255, 255, 0.95); padding: 15px;
            border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            font-family: 'Noto Sans KR', sans-serif;
            min-width: 200px;
            display: flex; flex-direction: column; gap: 10px;
        }

        .btn-common {
            width: 100%; padding: 10px; cursor: pointer;
            font-weight: bold; border-radius: 5px;
            transition: 0.2s; border: none; font-size: 14px;
        }

        .mode-move { background: #4CAF50; color: white; }
        .mode-attack { background: #f44336; color: white; }
        .btn-location { background-color: #2196F3; color: white; }
        .btn-location:hover { background-color: #1976D2; }

        .btn-kakao {
            display: block; width: 100%; padding: 10px 0;
            background-color: #FEE500; color: #000000;
            text-align: center; text-decoration: none;
            font-weight: bold; border-radius: 5px; font-size: 14px; box-sizing: border-box;
        }
        .btn-logout {
            display: block; width: 100%; padding: 5px 0;
            background-color: #999; color: white;
            text-align: center; text-decoration: none;
            border-radius: 4px; font-size: 12px; margin-top: 5px;
        }

        .attack-cursor { cursor: crosshair !important; }

        #login-area, #user-info { display: none; }
        .user-greeting { font-size: 14px; text-align: center; margin: 0; }
        .user-nickname { color: #2196F3; font-weight: bold; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="map"></div>
    <canvas id="pixelCanvas"></canvas>
    <canvas id="previewCanvas"></canvas>

    <div class="ui-panel">
        <button id="modeBtn" class="btn-common mode-move">ğŸ“ ì´ë™ ëª¨ë“œ</button>
        <button id="myLocBtn" class="btn-common btn-location">ğŸ§­ ë‚´ ìœ„ì¹˜ë¡œ</button>

        <hr style="width: 100%; border: 0; border-top: 1px solid #eee;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <span>ìƒ‰ìƒ:</span>
            <input type="color" id="colorPicker" value="#ff0000" style="cursor: pointer;">
        </div>
        <hr style="width: 100%; border: 0; border-top: 1px solid #eee;">

        <div id="login-area">
            <p style="font-size: 12px; color: #666; text-align: center; margin: 0 0 10px 0;">
                í”½ì…€ì„ ì°ìœ¼ë ¤ë©´<br>ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.
            </p>
            <a href="/oauth2/authorization/kakao" class="btn-kakao">ì¹´ì¹´ì˜¤ ë¡œê·¸ì¸</a>
        </div>

        <div id="user-info">
            <p class="user-greeting">ë°˜ê°‘ìŠµë‹ˆë‹¤!</p>
            <p class="user-greeting"><span id="nickname-display" class="user-nickname">User</span>ë‹˜</p>
            <a href="/logout" class="btn-logout">ë¡œê·¸ì•„ì›ƒ</a>
        </div>
    </div>
</div>

<script>
    // --- ì„¤ì • ---
    const GRID_SIZE = 0.0003;
    const MIN_ZOOM = 9;
    const MAX_ZOOM = 17;
    const EPSILON = 0.0000001;

    const KOREA_BOUNDS = new naver.maps.LatLngBounds(
        new naver.maps.LatLng(32.80, 124.60),
        new naver.maps.LatLng(38.55, 132.00)
    );

    let isAttackMode = false;
    let pixelMap = new Map();
    let myNickname = null;
    let isLoggedIn = false;

    // --- ì§€ë„ ì´ˆê¸°í™” ---
    const map = new naver.maps.Map('map', {
        center: new naver.maps.LatLng(37.3595704, 127.105399),
        zoom: 16,
        minZoom: MIN_ZOOM,
        maxZoom: MAX_ZOOM,
        maxBounds: KOREA_BOUNDS,
        draggable: true, scrollWheel: true, disableDoubleClickZoom: true, tileTransition: true
    });

    // --- ìº”ë²„ìŠ¤ ì„¤ì • ---
    const canvas = document.getElementById('pixelCanvas');
    const ctx = canvas.getContext('2d');
    const previewCanvas = document.getElementById('previewCanvas');
    const previewCtx = previewCanvas.getContext('2d');

    let isDrawing = false, needsRedraw = false;

    function scheduleDraw() {
        needsRedraw = true;
        if (!isDrawing) { isDrawing = true; requestAnimationFrame(drawLoop); }
    }

    function drawLoop() {
        if (needsRedraw) { drawPixels(); needsRedraw = false; requestAnimationFrame(drawLoop); }
        else { isDrawing = false; }
    }

    function resizeCanvas() {
        const size = map.getSize();
        if (size.width === 0 || size.height === 0) return;

        canvas.width = size.width;
        canvas.height = size.height;
        previewCanvas.width = size.width;
        previewCanvas.height = size.height;

        scheduleDraw();
    }
    window.addEventListener('resize', resizeCanvas);

    // --- ë©”ì¸ í”½ì…€ ê·¸ë¦¬ê¸° ---
    function drawPixels() {
        const projection = map.getProjection();
        const bounds = map.getBounds();

        if (!bounds || !projection) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const nwLat = bounds.getNE().lat();
        const nwLng = bounds.getSW().lng();
        const tlOffset = projection.fromCoordToOffset(new naver.maps.LatLng(nwLat, nwLng));

        const center = map.getCenter();
        const centerOffset = projection.fromCoordToOffset(center);
        const nextGridOffset = projection.fromCoordToOffset(
            new naver.maps.LatLng(center.lat() + GRID_SIZE, center.lng() + GRID_SIZE)
        );

        let pixelW = Math.abs(nextGridOffset.x - centerOffset.x);
        let pixelH = Math.abs(nextGridOffset.y - centerOffset.y);

        pixelW = Math.max(pixelW, 3);
        pixelH = Math.max(pixelH, 3);

        ctx.beginPath();
        const displayMap = new Map();
        pixelMap.forEach((p) => {
            // [ìµœì í™”] í™”ë©´ ì•ˆì— ìˆëŠ” ê²ƒë§Œ ë¦¬ìŠ¤íŠ¸ì—…
            if (bounds.hasLatLng(new naver.maps.LatLng(p.lat, p.lng))) {
                const snapLat = (Math.floor(p.lat / GRID_SIZE) * GRID_SIZE).toFixed(6);
                const snapLng = (Math.floor(p.lng / GRID_SIZE) * GRID_SIZE).toFixed(6);
                const displayKey = `${snapLat},${snapLng}`;
                displayMap.set(displayKey, { ...p, lat: parseFloat(snapLat), lng: parseFloat(snapLng) });
            }
        });

        displayMap.forEach((p) => {
            const drawLat = p.lat + GRID_SIZE;
            const drawLng = p.lng;
            const latLng = new naver.maps.LatLng(drawLat, drawLng);
            const pOffset = projection.fromCoordToOffset(latLng);
            const x = pOffset.x - tlOffset.x;
            const y = pOffset.y - tlOffset.y;

            ctx.fillStyle = p.color;
            ctx.fillRect(Math.floor(x), Math.floor(y), Math.ceil(pixelW), Math.ceil(pixelH));
        });
    }

    // --- ë§ˆìš°ìŠ¤ ì›€ì§ì„ (ë¯¸ë¦¬ë³´ê¸°) ---
    naver.maps.Event.addListener(map, 'mousemove', function(e) {
        if (!isAttackMode) {
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            return;
        }

        const projection = map.getProjection();
        const bounds = map.getBounds();
        if (!projection || !bounds) return;

        const rawLat = e.coord.lat();
        const rawLng = e.coord.lng();

        const snapLat = Math.floor(rawLat / GRID_SIZE) * GRID_SIZE;
        const snapLng = Math.floor(rawLng / GRID_SIZE) * GRID_SIZE;

        const nwLat = bounds.getNE().lat();
        const nwLng = bounds.getSW().lng();
        const tlOffset = projection.fromCoordToOffset(new naver.maps.LatLng(nwLat, nwLng));

        const center = map.getCenter();
        const centerOffset = projection.fromCoordToOffset(center);
        const nextGridOffset = projection.fromCoordToOffset(
            new naver.maps.LatLng(center.lat() + GRID_SIZE, center.lng() + GRID_SIZE)
        );
        let pixelW = Math.abs(nextGridOffset.x - centerOffset.x);
        let pixelH = Math.abs(nextGridOffset.y - centerOffset.y);
        pixelW = Math.max(pixelW, 3);
        pixelH = Math.max(pixelH, 3);

        previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);

        const drawLat = snapLat + GRID_SIZE;
        const drawLng = snapLng;
        const latLng = new naver.maps.LatLng(drawLat, drawLng);

        if (!KOREA_BOUNDS.hasLatLng(new naver.maps.LatLng(snapLat, snapLng))) {
            return;
        }

        const pOffset = projection.fromCoordToOffset(latLng);
        const x = pOffset.x - tlOffset.x;
        const y = pOffset.y - tlOffset.y;

        const selectedColor = document.getElementById('colorPicker').value;
        const r = parseInt(selectedColor.substring(1, 3), 16);
        const g = parseInt(selectedColor.substring(3, 5), 16);
        const b = parseInt(selectedColor.substring(5, 7), 16);

        previewCtx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.5)`;
        previewCtx.strokeStyle = "white";
        previewCtx.lineWidth = 1;

        previewCtx.fillRect(Math.floor(x), Math.floor(y), Math.ceil(pixelW), Math.ceil(pixelH));
        previewCtx.strokeRect(Math.floor(x), Math.floor(y), Math.ceil(pixelW), Math.ceil(pixelH));
    });

    // --- [ìˆ˜ì •ë¨] í•µì‹¬: ì˜ì—­ ê¸°ë°˜ ë°ì´í„° ë¡œë”© í•¨ìˆ˜ ---
    function fetchVisiblePixels() {
        const bounds = map.getBounds();
        if (!bounds) return;

        const sw = bounds.getSW(); // ë‚¨ì„œìª½
        const ne = bounds.getNE(); // ë¶ë™ìª½

        // API í˜¸ì¶œ: í˜„ì¬ í™”ë©´ì˜ ì¢Œí‘œ ë²”ìœ„ë¥¼ ì„œë²„ë¡œ ë³´ëƒ„
        fetch(`/api/pixels?minLat=${sw.lat()}&maxLat=${ne.lat()}&minLng=${sw.lng()}&maxLng=${ne.lng()}`)
            .then(res => res.json())
            .then(data => {
                if (Array.isArray(data)) {
                    // ë°›ì•„ì˜¨ ë°ì´í„°ë§Œ ì—…ë°ì´íŠ¸
                    data.forEach(p => updatePixelData(p));
                    scheduleDraw();
                }
            })
            .catch(err => console.warn("Load Error", err));
    }

    // [ì¤‘ìš”] ì§€ë„ê°€ ë©ˆì¶œ ë•Œ(idle), ì²˜ìŒ ë¡œë”©ë  ë•Œ(init) ë°ì´í„° ìš”ì²­
    naver.maps.Event.addListener(map, 'idle', fetchVisiblePixels);
    naver.maps.Event.addListener(map, 'init', fetchVisiblePixels);

    // í™”ë©´ ì´ë™/ì¤Œ ë³€ê²½ ì‹œ ê·¸ë¦¬ê¸° ì˜ˆì•½ (ë°ì´í„° ìš”ì²­ì€ idleì—ì„œ í•¨)
    naver.maps.Event.addListener(map, 'center_changed', scheduleDraw);
    naver.maps.Event.addListener(map, 'zoom_changed', scheduleDraw);

    function updatePixelData(pixel) {
        const key = `${pixel.lat.toFixed(4)},${pixel.lng.toFixed(4)}`;
        pixelMap.set(key, pixel);
        scheduleDraw();
    }

    // --- ì›¹ì†Œì¼“ (ì‹¤ì‹œê°„) ---
    const socket = new SockJS('/ws-pixel');
    const stompClient = Stomp.over(socket);
    stompClient.connect({}, () => {
        stompClient.subscribe('/topic/pixel', (msg) => {
            updatePixelData(JSON.parse(msg.body));
        });
    });

    // --- í´ë¦­ ì´ë²¤íŠ¸ (í”½ì…€ ì°ê¸°) ---
    naver.maps.Event.addListener(map, 'click', function(e) {
        if (!isAttackMode) return;
        if (!isLoggedIn) { alert("í”½ì…€ì„ ì°ìœ¼ë ¤ë©´ ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤!"); return; }

        const rawLat = e.coord.lat();
        const rawLng = e.coord.lng();

        const snapLat = Math.floor(rawLat / GRID_SIZE) * GRID_SIZE;
        const snapLng = Math.floor(rawLng / GRID_SIZE) * GRID_SIZE;

        if (!KOREA_BOUNDS.hasLatLng(new naver.maps.LatLng(snapLat, snapLng))) {
            alert("ëŒ€í•œë¯¼êµ­ ì˜í†  ë‚´ì—ë§Œ í”½ì…€ì„ ì°ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤!");
            return;
        }

        const color = document.getElementById('colorPicker').value;
        const newPixel = { lat: snapLat, lng: snapLng, color: color, userId: myNickname };

        updatePixelData(newPixel);

        fetch('/api/pixels', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(newPixel)
        })
        .then(res => res.text())
        .then(result => {
            if (result !== "SUCCESS" && result !== "ì„±ê³µ") {
                 scheduleDraw();
                console.warn("ì €ì¥ ì‹¤íŒ¨:", result);
            }
        })
        .catch(err => {
             scheduleDraw();
        });
    });

    // --- UI ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ---
    const modeBtn = document.getElementById('modeBtn');
    const myLocBtn = document.getElementById('myLocBtn');
    const mapDiv = document.getElementById('map');

    modeBtn.addEventListener('click', () => {
        isAttackMode = !isAttackMode;
        if (isAttackMode) {
            modeBtn.innerText = "âš”ï¸ ê³µê²© ëª¨ë“œ";
            modeBtn.className = "btn-common mode-attack";
            map.setOptions({ draggable: false, scrollWheel: false, disableDoubleClickZoom: true });
            mapDiv.classList.add('attack-cursor');
        } else {
            modeBtn.innerText = "ğŸ“ ì´ë™ ëª¨ë“œ";
            modeBtn.className = "btn-common mode-move";
            map.setOptions({ draggable: true, scrollWheel: true, disableDoubleClickZoom: true });
            mapDiv.classList.remove('attack-cursor');
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        }
    });

    myLocBtn.addEventListener('click', () => {
        if (!navigator.geolocation) {
            alert("ì´ ë¸Œë¼ìš°ì €ëŠ” ìœ„ì¹˜ ì •ë³´ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
            return;
        }
        navigator.geolocation.getCurrentPosition(
            (position) => {
                const lat = position.coords.latitude;
                const lng = position.coords.longitude;
                const userLocation = new naver.maps.LatLng(lat, lng);

                if (KOREA_BOUNDS.hasLatLng(userLocation)) {
                    map.setCenter(userLocation);
                    map.setZoom(16);
                } else {
                    alert("í˜„ì¬ ìœ„ì¹˜ê°€ ëŒ€í•œë¯¼êµ­ ì„œë¹„ìŠ¤ ì§€ì—­ ë°–ì…ë‹ˆë‹¤.");
                }
            },
            (error) => {
                if(error.code === 1) alert("ìœ„ì¹˜ ì •ë³´ ì œê³µì„ í—ˆìš©í•´ì£¼ì„¸ìš”.");
                else alert("ìœ„ì¹˜ ì •ë³´ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
            }
        );
    });

    // --- ë¡œê·¸ì¸ ì²´í¬ ---
    fetch('/api/user/me')
        .then(response => {
            if (response.ok) return response.json();
            throw new Error('ë¡œê·¸ì¸ ì•ˆë¨');
        })
        .then(user => {
            isLoggedIn = true;
            myNickname = user.nickname || "User";
            document.getElementById('login-area').style.display = 'none';
            document.getElementById('user-info').style.display = 'block';
            document.getElementById('nickname-display').innerText = myNickname;
        })
        .catch(error => {
            isLoggedIn = false;
            document.getElementById('login-area').style.display = 'block';
            document.getElementById('user-info').style.display = 'none';
        });

    setTimeout(resizeCanvas, 500);
</script>
</body>
</html>